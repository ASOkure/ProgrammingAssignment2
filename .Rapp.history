# Metrix inversion is usually a costly computation and there may be #some benefit to caching the inverse of a matrix rather than #computing it repeatedly. The following two functions are used to #cache the inverse of a matix#
# The makeCacheMatrix creates a list containing a function to#
# (a). set the value of the matrix#
# (b).  get the value of the matrix #
# (c). set the value of inverse of the matrix#
# (d). get the value of inverse of the matrix #
#
makeCacheMatrix <- function(x = matrix()) {#
inv <- NULL#
 set <- function(y) {#
    x <<- y#
    inv <<- NULL#
    }#
    get <- function() x#
    setinverse <- function(inverse) inv <<- inverse#
    getinverse <- function() inv#
  list(set=set, get=get, setinverse=setinverse,#
  getinverse=getinverse)#
}#
#
## The following function returns the inverse of the matrix. It first  # checks ifthe inverse has already been computed. If so, it gets the #
# result and skips the computation. If not, it computes the inverse, #
# sets the value in the cache via setinverse function.#
#
# This function assumes that the matrix is always invertible.#
cacheSolve <- function(x, ...) {#
     inv <- x$getinverse()#
      if(!is.null(inv)) {#
      	message("getting cached data.")#
           return(inv) #
           }#
           data <- x$get()#
            inv <- solve(data)#
            x$setinverse(inv)#
            inv#
  }          #
        ## Return a matrix that is the inverse of 'x'
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
x = rbind(c(1, -1/8), c(-1/8, 1))
m = makeCacheMatrix(x)
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
